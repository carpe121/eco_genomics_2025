---
title: "Tonsa DESeq2"
author: "Madeline Carpenter"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir="~/projects/eco_genomics_2025/transcriptomics/")
```

```{r, quiet=TRUE}
## Import libraries

library(DESeq2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(ggpubr)
library(vsn)  
library("pheatmap")
library("vsn")
```

```{r}
####################################################

### Import our data

####################################################

 
# Import the counts matrix
countsTable <- read.table("/gpfs1/home/m/c/mcarpen3/projects/eco_genomics_2025/transcriptomics/mydata/counts_matrix.txt", header=TRUE, row.names=1)
head(countsTable)
dim(countsTable)

countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
head(countsTableRound)

#import the sample description table
conds <- read.delim("/gpfs1/cl/ecogen/pbio6800/Transcriptomics/transcripts_quant/metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)
head(conds)
```

```{r}
####################################################

### Explore data distributions

####################################################

# Let's see how many reads we have from each sample
colSums(countsTableRound)
mean(colSums(countsTableRound))
```
Note that we are below the general rule of thumb recommendation of 20 million reads per sample. We're at about 12M reads/sample.

```{r}
barplot(colSums(countsTableRound), names.arg=colnames(countsTableRound),cex.names=0.5, las=3,ylim=c(0,21000000)) #change dims
abline(h=mean(colSums(countsTableRound)), col="blue", lwd=2)

mean(rowSums(countsTableRound)) # 
```
Despite lots of zeroes across the 119,000 transcripts, we still have an average of 2500 reads mapping per transcript.

```{r}
median(rowSums(countsTableRound)) #

apply(countsTableRound,2,mean) # 2 in the apply function does the action across columns
apply(countsTableRound,1,mean) # 1 in the apply function does the action across rows
hist(apply(countsTableRound,1,mean), ylim=c(0,100000),breaks=10000)
```

```{r}
####################################################

### Start working with DESeq2!

####################################################

# Correct column names to match conds
colnames(countsTableRound) <- substr(colnames(countsTableRound), start=1, stop=4)
```

```{r}
#### Create a DESeq object and define the experimental design here with the tilda
dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, design= ~ generation + line + line:generation)

dim(dds)
```

```{r}
# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds)
# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression
dds <- DESeq(dds)

# List the results you've generated
resultsNames(dds)
# Copy the results names
```

```{r}
####################################################

### Check the quality of the data by sample clustering and visualization

####################################################

# The goal of transformation "is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low."

library("pheatmap")
library("vsn")

# this gives log2(n + 1)
ntd <- normTransform(dds)
meanSdPlot(assay(ntd))

# Variance stabilizing transformation
vsd <- vst(dds, blind=FALSE)
meanSdPlot(assay(vsd))


sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$line, vsd$generation, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

# Note any outliers
```

```{r}
###############################################################

# PCA to visualize global gene expression patterns

# first transform the data for plotting using variance stabilization
vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("line","generation"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=line, shape=generation)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  coord_fixed()
```